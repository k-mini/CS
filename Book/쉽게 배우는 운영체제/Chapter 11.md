
# 📚 파일 시스템

## 📌 파일과 파일 시스템

### 파일 시스템

- 파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 맡기는 시스템
- 사용자가 직접 개입하면 다른 사용자의 파일을 훼손하거나 저장장치 내부를 어지럽혀 문제를 일으킬 수 있다.
- 파일 관리자, 파일 테이블이 존재
- 윈도우: FAT, NTFS   유닉스 : I-node

### 파일 디스크립터

- 사용자가 특정 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한(키)를 획득해야 한다.  
파일 접근 권한을 파일 디스크립터(file descriptor)라고 한다.

### 파일 시스템의 기능

| 기능 | 설명 |
| ---- | ---- |
| 파일 구성 | 사용자의 요구에 따라 파일과 디렉터리를 만든다. |
| 파일 관리 | 파일 생성, 수정, 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 사용자가 파일에 빨리 접근할 수 있도록 한다. |
| 접근 권한 관리 | 다른 사용자로부터 파일을 보호하기 위해 접근 권한을 관리한다. |
| 접근 방법 제공 | 파일을 읽고 쓰고 실행할 수 있도록 사용자에게 접근 방법을 제공한다. |
| 무결성 보장 | 파일의 내용이 손상되지 않도록 무결성을 보장한다. |
| 백업과 복구 | 사고로부터 파일을 보호하기 위해 백업과 복구 작업을 한다. |
| 암호화 | 파일을 암호화하여 악의적인 접근으로부터 파일을 보호 한다. |

### 블록과 파일테이블

- 데이터는 운영체제와 저장장치 간에 블록 단위로 전송
- 파일 관리자는 여러 섹터를 묶어 하나의 블록으로 만들고, 블록 하나에 주소 하나를 배정한다.

### 파일 분류와 확장자

- 실행 파일 : 운영체제가 메모리로 가져와 CPU를 이용하여 작업을 하는 파일. 즉 사용자의 요청으로 프로세스가 된 파일 ex) 이미지 뷰어 프로그램, 워드프로세서
- 데이터 파일 : 실행 파일이 작업하는 데 필요한 데이터를 모아놓은 파일. 연결 프로그램으로 열 수 있다. ex) 이미지 뷰어 프로그램의 사진파일, 뮤직 플레이어의 음악 파일, 워드프로세서의 문서파일
- 파일 구성 :  파일 헤더, 데이터
- 확장자 : 파일의 성격을 파악

### 파일 속성

- 파일 속성은 각 파일 헤더에 기록되며, 운영체제는 이런 파일 헤더를 파일 테이블에서 관리한다.

| 속성 |  특징 |
| ---- | ----- |
| name | 파일의 이름 |
| type | 파일의 종류 |
| size | 파일의 크기 |
| time | 파일의 접근 시간 |
| location | 파일의 위치 |
| accessibility | 파일의 접근 권한 |
| owner | 파일의 소유자 |

- 데이터 파일마다 자신에게 필요한 파일 속성을 따로 정의하여 사용하기도 한다. 이는 파일의 고유 헤더에 기록 된다.
- 파일 헤더 : 파일테이블에서 관리. 일반적인 내용, 저장장치에서 위치
- 고유 헤더 : 데이터 파일에는 응용 프로그램이 필요로 하는 고유 헤더가 존재. 파일의 버전 번호, 특수 정보 등등

### 파일 작업의 유형

- 파일 작업(파일 연산) => 파일을 지우거나 이름을 바꾸는 것과 같이 파일을 변경하는 것  
- 파일 자체를 변경하는 작업 => 윈도우의 \[파일탐색기\]에서 이루어지는 작업 
 
| 작업 | 설명 |
| ---- | ---- |
| open | 파일을 열기 |
| copy | 파일을 복사 |
| close | 파일을 닫기 |
| rename | 파일의 이름을 변경 |
| create | 새로운 파일을 생성 |
| list | 파일을 나열 |
| remove | 파일을 이동 |
| search | 파일을 찾기 |

- 파일 내용을 변경하는 작업 => 프로세스 입장에서 수행하는 것

| 작업 | 설명 |
| ---- | ---- |
| open() | 파일을 열기 |
| write() | 파일에 새로운 내용을 쓰기 |
| create() | 새로운 파일을 생성 |
| update() | 파일 내용 중 일부를 변경 |
| close() | 파일을 닫기 |
| insert() | 파일에 새로운 내용을 추가 |
| read() | 파일 내용을 읽기 |
| delete() | 파일 내용 중 일부를 지우기 |

### 파일 구조

- 순차 파일 구조 => 파일 내용이 하나의 긴 줄로 늘어선 형태. 순차 접근으로 접근이 가능 ex) 카세트 테이프
    - 장점 : 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없음, 구조가 단순, 순서대로 읽거나 저장할 때 매우 빠름
    - 단점 : 데이터의 변경이 잦을 때 적절하지 않음, 앞에서부터 순서대로 움직여야 함
- 인덱스 파일 구조 => 순차파일 구조에 인덱스 테이블을 추가한 구조 => 순처접근, 직접 접근  ex) 플로피디스크, CD-ROM, 하드디스크
    - 인덱스 순차접근 : 인덱스를 이용한 접근 방식
    - 특징 : 데이터의 빠른 접근이 필요한 시스템(데이터베이스)에 사용
    - 장점 : 다양한 접근이 가능
    - 단점 : ?
- 직접 파일 구조 => 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 변환하는 파일 구조
    - 해시 함수를 이용
    - 특정(해시) 함수를 이용하여 직접 접근이 가능, 해시 함수의 선정이 중요 (전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾아야 함)
    - 장점: 데이터 접근이 매우 빠르다.
    - 단점 : 빈 공간이 생겨서 저장장치 이용 효율이 떨어질 수 있음.(공간 효율성이 떨어진다) 잘못된 해시 함수 선정시 데이터가 고르게 분포되지 않음

## 📌 디렉터리 구조

### 디렉터리

- 관련 있는 파일을 하나로 모아놓은 곳
- 1개 이상의 자식 디렉터리를 가질 수 있고, 또한 1개 이상의 파일을 가질 수 있다.
- 디렉터리도 파일이다. => 파일 정보가 담겨 있다.
- 일반 파일과 마찬가지로 헤더를 가진다. => 디렉터리 헤더에는 디렉터리의 이름, 만든시간, 접근 권한 등의 정보가 기록되어 있다.

### 경로

- 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보
- 절대 경로 : 루트 디렉터리 기준으로 파일의 위치를 나타내는 방식. => ex) /windows/data/exm.c
- 상대 경로 : 현재 있는 위치를 기준으로 파일의 위치를 나타내는 방식 => ex) 현재 windows 디렉터리에 있다면, 위의 예시파일로 접근하기 위해서는 data/exm.c 이다.

### 디렉터리 구조

- 1 단계 구조 : 초기 파일 시스템의 디렉터리 구조. 루트 디렉터리에서만 새로운 디렉터리 생성 가능
- 트리 디렉터리 구조 : 다단계 디렉터리 구조라고도 불리며, 루트 디렉터리를 시작점으로 가지처럼 뻗어 나간 구조.
- 그래프 디렉터리 구조 : 트리 디렉터리 구조 + 바로가기같은 링크 기능. 순환이 존재.

### 마운트

- 파티션마다 파일 테이블이 따로 존재 => 파티션이 많으면 사용하기가 불편하다. 파티션이 많은 이유는 윈도우의 예전 파일시스템 FAT의 파티션 크기 제한이 있었기 때문
- 유닉스 명령어 마운트는 여러 개의 파티션을 통합하는 명령어이다. (유닉스는 서버용으로 만들어진 운영체제이므로 파일 테이블의 크기에 제한이 없다.)


## 📌 디스크 파일 할당

### 연속 할당과 불연속 할당

- 일반적으로 하나의 파일은 여러 개의 블록을 사용하는데, 여러 개의 블록을 어떻게 연결하는지에 따라 연속 할당과 불연속 할당 방식으로 구분된다.

### 연속 할당

- 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 방식
- 남은 공간 중 파일의 크기와 맞지 않는 연속된 공간이 없을 때는 연속 할당이 불가능

### 불연속 할당

- 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리하는 방식
- 연결 리스트를 이용한 연결 할당과 인덱스를 이용한 인덱스 할당

### 연결 할당(체인 할당)

- 윈도우의 FAT
- 파일 테이블에는 시작 블록에 대한 정보만 저장
- 파일 제어 테이블과 파일 할당 테이블이 존재
- 파일 제어 테이블 : 파일명과 블록 포인터 값 존재
- 파일 할당 테이블(FAT) 
    - 전체 블록에 대한 정보를 가진 테이블. 블록별로 다음 블록을 나타내는 블록번호를 포함 (맨 끝에는 널 값)  
    - 열(row)의 개수가 그 파티션에 존재하는 블록의 개수와 같다.
- 단점 : 디스크 용량이 테이블의 주소 크기로 제한. => 파티션 크기가 제한

### 인덱스 할당

- 유닉스의 I-node
- 인덱스 할당 방식에서는 테이블의 블록 포인터가 데이터 블록을 연결하는 것이 아니라, 데이터의 인덱스를 담고 있는 인덱스 블록을 연결한다.
- 인덱스 블록은 실제 데이터의 위치에 대한 정보를 순서대로 보관하고 있다. ex) 0,2,4,-1 => 데이터의 순서는 0번블록=>2번블록=>4번블록=>Null(-1은 널을 의미)이다.

### 디스크의 빈 공간 관리

- 블록의 크기를 크게 잡는다 => 적은 주소로 많은 양의 데이터 관리 가능 but 낭비되는 공간 생성(내부 단편화)
- 블록의 크기를 작게 잡는다 => 메모리 낭비를 줄일 수 있음 but 많은 양의 블록 포인터 필요

### 빈 공간 리스트 (free block list)

- 파일을 저장할 때마다 모든 테이블을 뒤져 빈 공간을 찾는 것은 비효율 => 디스크의 내부 단편화를 줄이고 빈 공간을 효율적으로 관리하자 => 빈 공간 리스트
- 파일을 삭제 한다 => 파일 테이블의 헤더 삭제 => 사용한 블록을 빈 공간 리스트에 등록
- 새로운 블록을 할당할때는 빈 공간 리스트에 먼저 들어온 블록부터 할당

## 📌 [심화] 유닉스 파일 특징

- 파일은 일반 데이터 파일과 실행 파일로 나뉜다.
- 윈도우는 확장자로 구분한다. => 파일의 확장자가 com, exe 일 경우 실행 파일
- 유닉스는 특정한 파일 확장자를 사용하지 않고 접근 패턴을 이용한다.

- r w x r w x r w x => 파일종류, (소유자의 읽기 쓰기 실행 권한 ) (소유자가 속한 그룹의 읽기 쓰기 실행 권한) (제삼자의 읽기 쓰기 실행 권한)  

파일 종류는 l(파일)과 d(디렉터리)로 이루어져 있다.  
여기서 접근 패턴에 x가 있으면 실행 가능한 파일이고 없으면 불가능한 파일이다.  
chmod 명령 : 접근 패턴 변경 명령어 ex) chmod 777은 모든 접근 패턴을 살린다. read는 4 write 2 excute는 1 을 의미

