
# 📚 CPU 스케줄링

## 📌 스케줄링의 개요

### CPU 스케줄러

- 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정

### 스케줄링의 단계

- 고수준 스케줄링 => 시스템 내의 전체 작업 수를 조절. 작업은 1개 또는 여러 개의 프로세스로 이루어진다.
- 중간수준 스케줄링 => 중지(Suspend)와 활성화(Active)로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.  
ex) 보류 상태 <-> 활성 상태
- 저수준 스케줄링 => 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정. ex) 준비 상태 -> 실행 상태 -> 대기 상태 ->... (chapter3에서 배운 내용)

### 스케줄링의 목적

- 공평성 => 모든 프로세스가 자원을 공평하게 배정
- 효율성 => 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링
- 안정성 => 우선순위를 사용하여 중요 프로세스가 먼저 작동 및 시스템 자원을 파괴하거나 점유하려는 프로세스로부터 자원을 보호
- 확장성 => 프로세스가 증가해도 시스템이 안정적으로 작동해야 함
- 반응 시간 보장 => 적절한 시간 안에 프로세스의 요구에 반응 해야 한다.
- 무한 연기 방지 => 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

## 📌 스케줄링 시 고려 사항

### 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식

### 선점형 비선점형 장단점

| 구분 | 선점형                                              | 비선점형                                                |
|------|-----------------------------------------------------|--------------------------------------------------------|
| 장점 | CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합 | CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적음 |
| 단점 | 문맥 교환의 오버헤드가 많다.                        | 기다리는 프로세스가 많아 처리율이 떨어짐                 |
| 사용 | 시분할 방식 스케줄러에 사용                         | 일괄 작업 방식 스케줄러에 사용                           |
| 중요도 | 높다                                             | 낮다                                                     |

### 프로세스 우선순위

- 커널 프로세스 > 일반 프로세스
- 전면 프로세스 > 후면 프로세스
- 대화형 프로세스 > 일괄 처리 프로세스
- 입출력 집중 프로세스 > CPU 집중 프로세스

### CPU 집중 프로세스와 입출력 집중 프로세스

- CPU 버스트 : CPU를 할당받아 실행하는 작업
- 입출력 버스트 : 입출력 작업
- CPU 집중 프로세스 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스.(CPU 버스트가 많은 프로세스)
- 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스. (입출력 버스트가 많은 프로세스)

### 사이클 훔치기

- 입출력 집중 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우 => 사이클 훔치기

### 전면 프로세스와 후면 프로세스

- 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스. 현재 입력과 출력을 사용하는 프로세스이며, 사용자와 상호작용이 가능 (= 상호작용 프로세스)
- 후면 프로세스 : 사용자와 상호작용이 없는 프로세스. 압축 프로그램처럼 사용자의 입력 없이 작동 ( = 일괄 작업 프로세스)

## 📌 다중 큐

### 프로세스 우선순위 배정 방식

- 고정 우선순위 방식 : 프로세스가 끝날 때까지 우선 순위가 바뀌지 않음 => 시스템의 변환에 대응이 어려움 => 작업 효율 떨어짐
- 변동 우선순위 방식 : 프로세스 작업 중간에 우선 순위가 변하는 방식 => 시스템의 효율성을 높일 수 있음

### 준비 상태의 다중 큐

- 우선순위 별로 다중 큐를 생성

### 대기 상태의 다중 큐

- 입출력이 완료되기를 기다리는 프로세스가 모여 있는 곳
- 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 모아놓는다.

## 📌 스케줄링 알고리즘

### 대기 시간

- 프로세스가 생성된 후 실행되기 전까지 대기하는 시간

### 응답 시간

- 첫 작업(준비 큐 도착)을 시작한 후 첫 번째 출력(반응)이 나오기까지의 시간

### 실행 시간

- 프로세스 작업이 시작된 후 종료되기까지의 시간

### 반환 시간

- 대기시간을 포함하여 실행이 종료될 때까지의 시간

### 스케줄링 알고리즘의 종류

- 비선점형 : FCFS, SJF, HRN
- 선점형 : 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐
- 둘 다 : 우선순위

### FCFS (First Come First Served)

- 준비 큐에 도착한 대로 CPU를 할당
- 단점 : 콘보이 효과(호위 효과)

### SJF (Shortest Job First)

- 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 작업부터
- 단점 : 아사 현상(공평성 위배), 현대 운영체제가 프로세스의 종료 시간을 예측하기 어려워지면서 사용하기가 어렵다.

### HRN (Highest Response Ratio Next)

- 우선순위 : (대기시간 + CPU 사용시간) / CPU 사용시간
- 아사현상 완화 
- 여전히 공평성이 위배

### 라운드 로빈 (Round Robin)

- 한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐에 맨 뒤로 가서 자기 차례를 기다리는 방식
- 문맥교환이 자주 일어난다. => 적절한 타임 슬라이스 설정 필요

### SRT 우선 스케줄링 (Shortest Remaining Time)

- SJF(비선점) + RR(선점) 방식을 혼합
- 기본적으로 RR을 사용하지만 CPU를 할당 받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택
- SJF에는 없는 문맥교환 작업 추가
- 프로세스의 종료시간 예측 어려움 및 아사 현상으로 잘 사용 X

### 우선순위 스케줄링

- 프로세스의 중요도에 따라 우선순위를 정하여 구현
- 다양한 기준으로 우선순위를 정할 수 있기 때문에 비선점 방식과 선점형 방식이 가능
- 공평성 위배 -> 아사현상
- 준비 큐에 있는 프로세스 순서 무시하고 프로세스의 우선순위를 매번 바꿈 -> 오버헤드 발생 -> 시스템 효율성 떨어뜨린다.

### 다단계 큐

- 우선순위에 따라 준비 큐를 여러개 사용하는 방식
- 상단의 큐에 있는 모든 프로세스 작업이 끝나야 다음 우선순위 큐의 작업 시작
- 우선순위에 따라 타임 슬라이스 조절 가능 => 타임 슬라이스 길게하면 FCFS, 짧게하면 RR이 가능하므로 => 우선순위에 따라 다양한 스케줄링이 가능

### 다단계 피드백 큐

- CPU를 사용하고 난 프로세스의 우선순위가 낮아진다
- CPU를 사용하고 난 프로세스는 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.
- 우선순위에 따라 타임 슬라이스의 크기가 다르다.
- 우선순위가 낮을 수록 타임슬라이스가 커짐

## 📌 [심화] 인터럽트 처리

### 인터럽트

- 입출력을 요청하고 입출력이 완료되면 이벤트를 발생
- 유닉스에서 Ctrl + C
- 프로세스가 다른 프로세스 메모리 영역 침범

### 동기적 인터럽트 (= 사용자 인터럽트)

- 프로세스가 실행 중인 명령어로 발생하는 인터럽트
- 프로그램상의 문제때문에 발생하는 인터럽트 (다른 사용자의 메모리영역에 접근, 오버플로, 언더플로)
- 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
- 입출력장치 같은 주변장치의 조작에 의한 인터럽트
- 산술 연산 중 발생하는 인터럽트

### 비동기적 인터럽트

- 실행 중인 명령어와 무관하게 발생하는 인터럽트
- 하드디스크 읽기 오류
- 메모리 불량같은 하드웨어적인 오류
- 사용자가 직접 작동하는 키보드,마우스 인터럽트

### 커널모드

- 운영체제와 관련된 커널 프로세스가 실행

### 사용자 모드

- 사용자 프로세스가 실행되는 상태

### 이중 모드

- 운영체제가 커널 모드와 사용자 모드를 전환하며 일 처리를 하는 것

### 사용자가 커널 모드로 진입하는 경우

- 시스템 호출 (자발적)
- 인터럽트를 발생 (프로세스가 잘못된 명령을 수행 -> 동기적 인터럽트 -> 인터럽트 핸들러(커널 프로세스) -> 프로세스 강제 종료)



