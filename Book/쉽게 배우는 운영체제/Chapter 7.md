
# 📚 물리 메모리 관리

## 📌 메모리 관리의 개요

### 메모리 관리의 이중성

- 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌을 일으키는 것
- 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고 싶어 함.

### 컴파일러와 인터프리터

- 컴파일러 => 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행 ex) C 언어, 자바 등
- 인터프리터 => 소스코드를 한 행씩 번역하여 실행 ex) 자바스크립트, 베이직, 파이썬

| 구분 | 자바 | 자바스크립트 |
| --- | -- | -- |
| 변수 | 변수를 선언해야 함 | 변수를 선언할 필요가 없음 |
| 실행 | 컴파일 후 실행 | 한 줄씩 실행 | 
| 장점 | 오류 찾기와 코드 최적화, 분할 컴파일에 의한 공동 작업이 가능 | 실행이 편리 | 
| 사용프로그램 | 대형 프로그램 | 간단한 프로그램 |

### 컴파일러의 목적

- 오류 발견 => 심벌 테이블을 사용. 심벌테이블은 변수 선언부에 명시한 각 변수의 이름과 종류를 모아놓은 테이블
- 코드 최적화

### 메모리 관리자의 역할

- 메모리 관리는 메모리 관리자가 담당한다.
- 메모리 관리 유닛(Memory Manage Unit, MMU)라는 하드웨어인데 일반적으로 메모리 관리자라고 부른다.

### 메모리 관리자의 작업

- 가져오기 작업 => 프로세스와 데이터를 메모리로 가져오는 작업
- 배치 => 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려놓을지 결정하는 작업이다. 배치 작업 전에 메모리를 어떤 크기로 자를 것인지가 매우 중요하다.
- 재배치 => 꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보내는 작업
- 메모리 관리자는 가져오기, 배치, 재배치 작업 시 다음과 같은 정책을 수립하여 그 정책에 따라 메모리를 관리한다.
    - 가져오기 정책 : 프로세스가 필요로 하는 데이터를 언제 가져올지 결정하는 정책 ex) 필요할때 가져온다 or 필요하다고 예상되는 데이터를 미리 가져온다.
    - 배치 정책 : 가져온 프로세스를 어떤 위치에 올려놓을지 결정하는 정책 ex) 같은 크기로 자른다(페이징) or 프로세스의 크기에 맞게 자른다(세그먼테이션)
    - 재배치 정책 : 어떤 프로세스를 내보낼지 결정하는 정책 ex) 교체 알고리즘

## 📌 메모리 주소

### 컴퓨터 메모리의 크기

| 구분 | 32bit CPU | 64bit CPU |
| -- | -- | -- |
| 주소 범위 | 0 ~ 2^32 - 1 번지 | 0 ~ 2^64 - 1 번지 |
| 총크기 | 2^32바이트(약 4GB) | 2^64바이트(약 16,772,216TB) |

### 물리 주소 공간

- 컴퓨터에 설치된 메모리의 주소 공간 (하드웨어 입장에서 바라본 주소 공간)

### 논리 주소 공간

- 사용자 입장에서 바라본 주소 공간

### 경계 레지스터

- 사용자 프로세스가 운영체제 영역에 침범하는 것을 막음

### 절대 주소와 상대 주소

- 절대 주소 => 실제 물리 주소 => 메모리 관리자 입장에서 바라본 주소
- 상대 주소 => 사용자 영역이 시작되는 번지를 0 번지로 변경하여 사용하는 주소 지정 방식 => 사용자 프로세스 입장에서 바라본 주소

| 구분 | 절대 주소 | 상대 주소 | 
| -- | -- | -- |
| 관점 | 메모리 관리자 입장 | 사용자 프로세스 입장 |
| 주소 시작 | 물리 주소 0번지부터 시작 | 물리주소와 관계없이 항상 0 번지부터 시작 |
| 주소 공간 | 물리 주소(실제 주소) 공간 | 논리 주소 공간 |

### 상대 주소를 절대 주소로 변환하는 과정

- 프로세스 실행 중 메모리 관리자가 빠르게 처리
- 재배치 레지스터에 주소 변환의 기본이 되는 주소값을 저장(메모리에서 사용자 영역의 시작 주소값이 저장됨.)

## 📌 단일 프로그래밍 환경에서의 메모리 할당

### 메모리 오버레이(memory overlay)

- 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
- 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용
- 필요한 중요한 모듈만 올려놓고 나머지는 필요할 때마다 메모리에 가져와 사용

### 스왑 영역

- 메모리가 모자라서 쫓겨난 프로세스를 저장장치의 저장하는 영역
- 메모리 관리자가 관리 (원래 하드디스크 같은 저장장치는 저장장치 관리자가 관리)
- 스왑 인 : 메모리 <= 스왑영역
- 스왑 아웃 : 메모리 => 스왑 영역

## 📌 다중 프로그래밍 환경에서의 메모리 할당

### 메모리 분할 방식

- 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나눈다. (연속 메모리 할당, 프로세스가 연속된 공간에 배치)
- 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은(일정한) 크기로 나눈다. (비연속 메모리 할당, 프로세스가 분산되어 배치)

### 가변 분할과 고정 분할의 장단점

| 구분 | 가변 분할 방식 | 고정 분할 방식 |
| ---- | ------ | -- |
| 메모리 단위 | 세그먼테이션 | 페이징 |
| 장점 | 하나의 프로세스를 연속된 공간에 배치 | 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월 |  
| 단점 | 메모리 통합 등의 부가적인 작업이 필요하므로 메모리 관리가 복잡 | 프로세스가 분할되어 치리됨 |
| 단편화 | 외부 단편화 | 내부 단편화 |

### 가변 분할 방식 해결 방법

- 메모리 배치 방식이나 조각 모음을 사용

### 메모리 배치 방식

- 작은 조각이 발생하지 않도록 프로세스를 배치하는 것 ( 최초,최적,최악을 사용해도 단편화 현상이 발생됨)
- 최초 배치 : 프로세르를 배치할 때 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치
- 최적 배치 : 메모리 빈 공간을 모두 파악 한 후 가능한 크기 가운데 가장 작은 공간에 프로세스를 배치
- 최악 배치 : 메모리 빈 공간을 모두 파악 한 후 가능한 크기 가운데 가장 큰 공간에 프로세스를 배치

### 조각 모음

- 메모리 조각이 발생했을 때 작을 조각들을 모아서 큰 덩어리로 만드는 작업

### 버디 시스템 (가변 분할 방식)

- 가변 분할 방식의 단점인 외부 단편화 완화 방법
1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치한다.
2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다. (고정 분할 방식과 유사)
3. 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다.

## 📌 [심화] 컴파일과 메모리 관리

- 컴파일러: 기계어로 번역, 오류 점검, 코드 최적화
