
# 📚 가상 메모리 관리

## 📌 요구 페이징 (가져오기 정책)

### 요구 페이징

- 프로세스가 요청할 때 메모리로 가져오는 방법

### 요구 페이징의 개요

- 모든 메모리를 미리 올려 놓으면 메모리 관리가 복잡
- 필요한 모듈만 올리는 게 메모리가 효율적으로 관리  및 절약하기 쉬우며, 응답속도도 향상 된다.

### 페이지 테이블 엔트리의 구성

- 접근 비트 : 페이지가 메모리에 올라온 후 사용한 적이 있는지
- 변경 비트 : 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지
- 유효(현재) 비트 : 페이지가 실제 메모리에 있는지
- 읽기,쓰기,실행 비트 : 페이지에 대한 읽기 권한, 쓰기 권한, 실행 권한을 나타내는 비트. 이 세 개를 합쳐 접근 권한 비트라고 부른다.
- 주소 필드 : 프레임 번호

### 페이지 부재

- 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황
- 페이지 부재가 발생하면 메모리 관리자는 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다.

### 페이지 교체 알고리즘

- 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘

### 대상 페이지

- 페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지

### 지역성

- 페이지 교체 알고리즘은 지역성을 바탕으로 한다.
- 지역성은 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질을 말한다.
- 크게 공간의 지역성, 시간의 지역성, 순차적 지역성으로 나뉜다.
    - 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다.
    - 시간의 지역성 : 현재를 기준으로 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다.
    - 순차적 지역성 : 여러 작업이 순서대로 진행되는 경향이 있다.

## 📌 페이지 교체 알고리즘 (재배치 정책)

### 페이지 교체 알고리즘의 종류

| 종류 | 알고리즘 | 특징 |
| ---- | -------- | ---- |
| 간단한 알고리즘 | 무작위 | 무작위로 대상페이지 선정 |
| 간단한 알고리즘 | FIFO | 처음 메모리에 올라온 페이지 선정 |
| 이론적 알고리즘 | 최적 | 미래의 접근 패턴을 보고 대상 페이지 선정 |
| 최적 근접 알고리즘 | LRU | 시간적으로 멀리 떨어진 페이지 선정 |
| 최적 근접 알고리즘 | LFU | 사용 빈도가 적은 페이지 선정 |
| 최적 근접 알고리즘 | NUR | 최근에 사용한 적이 없는 페이지 선정 |
| 최적 근접 알고리즘 | FIFO 변형 | FIFO 알고리즘을 변형 |

### 무작위 페이지 교체 알고리즘

- 대상 페이지를 특별한 로직없이 무작위로 선정

### FIFO 페이지 교체 알고리즘

- 선입선출 페이지 교체 알고리즘
- 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정

### 최적 페이지 교체 알고리즘

- 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정
- 미래의 접근 패턴을 아는게 불가능하여 실제로 구현 불가

### LRU 페이지 교체 알고리즘

- 최근 최소 사용 페이지 교체 알고리즘 (Least Recently Used page replacement algorithm)
- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 선정
- 시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있음
- 공간을 낭비하는것이 단점

### LFU 페이지 교체 알고리즘

- 최소 빈도 사용 알고리즘(Least Frequency Used page replacement algorithm)
- 가장 적게 사용된 페이지를 대상 페이지로 선정하여 스왑영역으로 옮긴다.
- 낭비되는 메모리 공간이 많다는 것이 단점

### NUR 페이지 교체 알고리즘

- 최근 미사용 페이지 교체 알고리즘 (Not Used Recently page replacement algorithm)
- LRU, LFU와 성능이 비슷하나 불필요한 공간 낭비 문제를 해결
- 추가 비트 2개(참조비트,변경비트)만 사용하여 미래를 추정
- 참조 비트 : 페이지에 접근(read/execute)하면 1이 된다.
- 변경 비트 : 패이지가 변경(write/append)되면 1이 된다.
- 2bit만 추가하여 다른 알고리즘과 유사한 성능을 낼 뿐만 아니라 쉽게 구현할 수 있다는 장점 때문에 가장 많이 사용

### FIFO 변형 알고리즘

- 2차 기회 페이지 알고리즘 : 페이지 부재 없이 성공한 페이지를 큐의 맨 뒤로 이동
- 시계 알고리즘 : 원형 큐를 사용하며, 대상 페이지를 가리키는 포인터를 사용한다. 페이지 성공시 해당 페이지의 참조비트가 하나씩 추가된다. 
페이지 부재시 포인터가 가리키는 페이지를 대상 페이지로 선정하고 포인터가 밑으로 이동하는데 이때 참조비트가 1인 페이지를 건너뛰면서 0으로 바꾼다.
- FIFO 방식을 기본으로 하되 페이지에 접근할 때마다 순서에 변화를 주어 성능을 향상
- 대상 포인터와 각 페이지당 참조비트 하나만 추가해서 NUR 페이지 교체 알고리즘보다 추가 공간이 적게 들지만 알고리즘이 복잡하고 계산량이 많다

## 📌 스레싱과 프레임 할당

### 스레싱

- 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태

### 물리 메모리의 크기와 스레싱

- 스레싱은 메모리의 크기가 일정할 경우 멀티프로그램의 수와 관계가 있다.
- 멀티프로그래밍 정도가 너무 높으면 스레싱이 발생

### 프레임 할당 방식

- 정적 할당  => 프로세스 초기에 프레임을 나누어준 후 그 크기를 고정
    - 균등 할당 방식
    - 비례 할당 방식
- 동적 할당  => 시시각각 변하는 프레임 요청을 수용하는 방식
    - 작업집합 모델
    - 페이지 부재 빈도
### 균등 할당

- 프로세스의 크기와 상관 없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당

### 비례 할당

- 프로세스의 크기에 비례하여 프레임을 할당

### 정적 할당의 문제점

- 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못함
- 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비

### 작업집합 모델

- 지역성 이론을 바탕으로 함.  (가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다)
- 작업집합 크기 : 작업집합에 들어갈 최대 페이지 수, 물리 메모리에 유지할 페이지의 크기, 작업집합 크기 만큼 접근할 때마다 집합을 갱신
- 작업집합 윈도우 : 작업집합에 포함되는 페이지 범위
- 어떤 프레임을 물리 메모리에 유지해야 하는지는 알 수 있지만 프로세스에 프레임을 얼마나 할당해야 하는지는 알 수 없다.
- 프로세스의 성능을 높이는 방법이지만 스레싱 문제를 해결하지는 못한다.

### 페이지 부재 빈도

- 프로세스가 필요로 하는 페이지의 양을 동적으로 결정하는 방법
- 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산한다. 
- 부재 비율 상한선 초과 -> 프레임 추가 -> 하한선 미만 -> 프레임 회수 -> ... 
- 페이지 비율의 상한선과 하한선을 설정한 후 실시간으로 적정 페이지 할당량을 조절

## 📌 [심화] 프레임 관련 이슈

### 전역 교체

- 전체 프레임을 대상으로 교체 알고리즘을 적용

### 지역 교체

- 현재 실행 중인 프로세스의 프레임을 대상으로 교체 알고리즘을 적용
- 장점 : 페이지 교체가 다른 프로세스에 영향을 미치지 않는다
- 단점 : 자주 사용하는 페이지가 스왑 영역으로 옮겨져 시스템의 효율이 떨어진다.
- 다른 프로세스의 스레싱을 줄일 수 있지만 반대로 실행 중인 프로세스의 성능을 떨어뜨릴 수도 있다. 따라서 전체 시스템 입장에서는 전역 교체 방식이 지역 교체 방식보다 효율적이다.

### 페이지 테이블 크기 계산

- 윈도우 NT는 32bit CPU는 가상 주소 공간의 크기가 2^32 B -> 4GB 이고 페이지 1개의 크기는 2^12(4096)B 이다.
- 따라서 가상 주소 공간의 페이지 수는 2^32 / 2^12 = 2^20 = 1048576개 이다.
- 0~1048575를 페이지 테이블로 나타내려면 20bit가 필요한데 차지하는 공간은 총 1,049,576개(행의 수) * 20bit(행의 각 숫자를 나타내는데 필요한 비트) = 약 2.62MB이다. 
- 페이지의 크기가 커지면 페이지 테이블의 크기 감소 -> but 내부 단편화 발생

### 쓰기 시점 복사

- 프로세스를 복사한 후 프레임을 공유하다가, 데이터의 변화가 있을때 데이터의 복사(새로운 프레임 할당)을 진행. (최대한 복사를 미룸)


