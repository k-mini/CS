
# 📚 회복과 병행 제어

## 📌 트랜잭션

### 트랜잭션

- 하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 것, 논리적인 작업의 단위
- 일반적으로 데이터베이스 연산은 SQL문으로 표현되므로 작업 수행에 필요한 SQL문들의 모임이기도 한다.
- 데이터베이스에 장애가 발생했을 때 데이터를 복구하는 작업의 단위

### 트랜잭션의 특성 (ACID 특성)

- 원자성(atomicity)
    - 트랜잭션의 연산이 모두 정상적으로 수행되거나 하나도 수행되지 않아야 한다. (all or nothing)
- 일관성(consistency)
    - 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태여야 한다.
- 격리성(isolation, 고립성)
    - 수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산에 접근할 수 없다.
- 지속성(durability, 영속성)
    - 트랜잭션의 수행이 완료된 후에 데이터베이스에 반영한 결과는 영구적이어야 한다.

### 트랜잭션의 연산

- commit 연산 : 작업 완료 => 트랜잭션이 성공적으로 수행되었음을 선언
- rollback 연산 : 작업 취소 => 트랜잭션을 수행하는 데 실패했음을 선언

### 트랜잭션의 상태

- 활동 상태 (active)
    - 트랜잭션이 수행을 시작하여 현재 수행 중인 상태
- 부분 완료 상태 (partially committed)
    - 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태
- 완료 상태 (commited)
    - 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
- 실패 상태 (failed)
    - 장애가 발생하여 트랜잭션의 수행이 중단된 상태
- 철회 상태 (aborted)
    - 트랜잭션의 수행 실패로 rollback 연산을 실행한 상태

## 📌 장애와 회복

### 장애의 유형

- 트랜잭션 장애
- 시스템 장애
- 미디어 장애

### 저장 장치의 종류

- 휘발성 저장 장치
- 비휘발성 저장 장치
- 안정 저장 장치

### 데이터베이스 저장 연산

- input(X) : 메인 메모리 버퍼 블록 <= 디스크 블록
- output(X) : 메인 메모리 버퍼 블록 => 디스크 블록

- read(X) : 프로그램의 변수 <= 메인 메모리 버퍼 블록
- write(X) : 프로그램의 변수  => 메인 메모리 버퍼 블록

### 데이터베이스 회복을 위해 복사본을 만드는 방법

- 덤프(dump) : 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사
- 로그(log)
    - 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도 파일에 기록하는 방법

### 회복 연산

- redo (재실행)
    - 가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그을 이용해 복사본이 만들어진 이후에  
    실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구 (전반적으로 손상된 경우에 주로 사용)
- undo (취소)
    - 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구  
    (변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 주로 사용)

### 회복 기법의 분류

- 로그 회복 기법
    - 즉시 갱신 회복 기법
    - 지연 갱신 회복 기법
- 검사 시점 회복 기법
- 미디어 회복 기법

## 📌 병행 제어

### 병행 수행

- 여러 개의 트랜잭션을 동시에 수행하는 것. 인터리빙 방식으로 진행

### 병행 수행시 발생하는 문재

- 갱신 분실 => 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어서 변경 연산이 무효화
- 모순성    => 일관성 없는 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생
- 연쇄 복귀
    - 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것

### 병행 제어

- 병행 수행 시 문제가 발생하지 않고 정확한 결과를 얻을 수 있도록 트랜잭션의 수행을 제어

### 트랜잭션 스케줄

- 트랜잭션에 포함되어 있는 연산들을 수행하는 순서

- 직렬 스케줄 => 인터리빙 방식을 이용하지 않고 트랜잭션별로 연산들을 순차적으로 실행
- 비직렬 스케줄 => 인터리빙 방식을 이용하여 트랜잭션들을 병행해서 수행
- 직렬 가능 스케줄 => 직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄

### 병행 제어 기법

- 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용
- 모든 트랜잭션들이 준수하면 직렬 가능성을 보장되는 규악

### 로킹(locking) 기법

- 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산으로 제어
- 로킹 단위가 커질수록 병행성이 낮아지지만 제어가 쉽고, 로킹 단위가 작아질수록 제어가 어렵지만 병행성이 높아진다.

- lock 연산 : 트랜잭션이 데이터에 독점권을 요청하는 연산
    - 공용 lock
    - 전용 lock
- unlock 연산 : 트랜잭션이 데이터에 독점권을 반환하는 연산

### 2단계 로킹 규약

- 트랜잭션이 lock과 unlock 연산을 확장 단계와 축소 단계로 나누어 수행해야 한다.  
모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성을 보장받는다.

- 확장 단계 : 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계
- 축소 단계 : 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계









